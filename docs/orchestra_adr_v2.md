# Orchestra – Architecture Decision Records (v3)

Этот документ фиксирует ключевые архитектурные решения для целевой версии Orchestra. Все ADR самодостаточны и не опираются на предыдущие версии.

## ADR-0001: Домен независим от протоколов (Channel-Agnostic Domain)

**Статус:** Accepted
**Дата:** 2025-11-14

### Контекст

Система должна тестировать бизнес-процессы, в которых участвуют HTTP, Kafka, gRPC, базы данных и очереди. На уровне домена важны шаги процесса и их побочные эффекты, а не детали транспорта.

### Решение

- Ядро доменной модели (Process, ProcessVersion, ScenarioSuite, TestScenario, ScenarioStep, TestRun, TestRunReport) не содержит жёстких зависимостей от конкретных протоколов.
- Для описания транспорта используются абстракции:
  - `ChannelType` (HTTP_REST, KAFKA, GRPC, DB, QUEUE).
  - `EndpointRef` (protocolId, serviceName, endpointName).
  - `ActionDefinition`, `StepExpectations`, `StepResult`.

### Альтернативы

1. Зашить HTTP/OpenAPI в домен и позже адаптировать под Kafka/gRPC.
2. Делать отдельные движки и модели под каждый протокол.

### Причины выбора

- Требования домена — тестировать процессы и побочные эффекты, а не отдельные HTTP-эндпоинты.
- Возможность комбинировать шаги разных типов в одном сценарии.
- Расширяемость: новый протокол = новый плагин, а не новая доменная модель.

### Последствия

Плюсы:

- Гибкая и расширяемая архитектура.
- Домен «говорит» языком бизнеса («шаг процесса», «проверка побочного эффекта»).

Минусы:

- Усложнение проектирования SPI.
- Нужна аккуратная нормализация ActionResult/Violations.

### Реализация в рамках хакатона

- Домен и SPI реализуются полностью.
- Полный протокол — HTTP/OpenAPI.
- Kafka/gRPC — интерфейсы и скелеты.

---

## ADR-0002: Плагинная модель протоколов (ProtocolPlugin)

**Статус:** Accepted
**Дата:** 2025-11-14

### Контекст

Нужно поддерживать разные протоколы и спецификации без изменения базовой логики Execution Engine.

### Решение

Вводится интерфейс `ProtocolPlugin` со следующими компонентами:

- `ProtocolSpecParser` — парсер спецификаций протокола.
- `EndpointMatcher` — маппинг шагов процессов на эндпоинты/топики/методы.
- `StepExecutor` — выполнение шага сценария.
- `ContractValidator` — валидация ответа/события по контракту.

Создаётся `ProtocolRegistry` (id → ProtocolPlugin).

### Альтернативы

1. Один «комбайн» с `switch(protocolId)` внутри ядра.
2. Отдельные микросервисы под каждый протокол.

### Причины выбора

- OCP: добавление протоколов без изменения существующего кода домена.
- Отделение ответственности: парсинг, маппинг, выполнение, валидация.

### Последствия

Плюсы:

- Расширяемость и независимое развитие плагинов.
- Тестируемость каждого плагина отдельно.

Минусы:

- Требуется управление жизненным циклом плагинов.
- Команде нужно понимать SPI.

### Реализация в рамках хакатона

- `HttpProtocolPlugin` реализуется полностью (OpenAPI, HTTP-вызовы, JSON Schema).
- `KafkaProtocolPlugin` и `GrpcProtocolPlugin` создаются как заготовки (SPI + базовый каркас).

---

## ADR-0003: PostgreSQL + JSONB как основное хранилище

**Статус:** Accepted
**Дата:** 2025-11-14

### Контекст

Структуры шагов, ожиданий, результатов и отчётов эволюционируют. Жёстко нормализованная схема приведёт к постоянным миграциям.

### Решение

- Использовать PostgreSQL как основную БД.
- Хранить гибкие части в jsonb:
  - ProcessVersion.controlFlowGraph.
  - ScenarioStep.action, ScenarioStep.expectations.
  - TestDataSet.data.
  - StepResult payload/violations.
  - TestRunReport.summary/errorsSummary/recommendations.
- Ключевые связи (tenantId, processId, scenarioId, runId, stepId) — реляционные поля с индексами.

### Альтернативы

1. Сильно нормализованная реляционная схема.
2. Отдельная документная БД.

### Последствия

Плюсы:

- Гибкость изменения схем.
- Возможность аналитики SQL + JSONB.

Минусы:

- Сложность индексации JSONB.
- Валидация структуры смещается в приложение.

### Реализация в рамках хакатона

- Создаётся базовая DDL со ссылками + jsonb.
- Управление миграциями через Flyway/Liquibase.
- Минимальные индексы, продвинутая оптимизация — post-MVP.

---

## ADR-0004: SPA Frontend (React + TypeScript)

**Статус:** Accepted
**Дата:** 2025-11-14

### Контекст

Нужен богатый UI для работы с процессами, сценариями, наборами данных и отчётами. Команда знакома с React/TS.

### Решение

- Фронтенд — SPA на React + TypeScript.
- Использовать React Router, TanStack Query.
- State-management (Zustand или Redux Toolkit) при необходимости.
- bpmn-js / mermaid viewer для диаграмм.
- Общение с backend по REST (OpenAPI 3.0).

### Альтернативы

1. Многостраничное серверное приложение.
2. Другие фреймворки (Vue/Angular).

### Последствия

Плюсы:

- Быстрая разработка и богатая экосистема.
- Удобная интеграция визуальных компонентов.

Минусы:

- Отдельный пайплайн сборки frontend.
- SEO не приоритет, но SPA сложнее индексировать (не критично).

### Реализация в рамках хакатона

- Импорт процессов и спецификаций.
- Список сценариев и страница сценария.
- Запуск прогона и просмотр результатов.
- Экран отчёта (минимальный).

---

## ADR-0005: AI как отдельный сервис

**Статус:** Accepted
**Дата:** 2025-11-14

### Контекст

Генерация тестовых данных и аналитика отчётов требуют гибкости: возможна смена AI-провайдера, ключей, лимитов.

### Решение

- Выделить `ai-service` как отдельный сервис/контейнер.
- Orchestra API общается с ним по HTTP/gRPC.
- `ai-service` инкапсулирует интеграцию с LLM, промпты, пост-обработку.

### Альтернативы

1. Встраивать AI-логику в orchestra-api.
2. Выносить AI в отдельный продукт с собственной БД и UI.

### Последствия

Плюсы:

- Независимое масштабирование AI.
- Возможность менять провайдера без затрагивания ядра.

Минусы:

- Дополнительное сетевое взаимодействие и мониторинг.

### Реализация в рамках хакатона

- Допустима упрощённая/заглушечная реализация `ai-service`.
- Должен быть вызов генерации данных и блок «Рекомендации» в отчёте (даже упрощённый).

---

## ADR-0006: Execution Engine через очередь задач и воркеры

**Статус:** Accepted
**Дата:** 2025-11-14

### Контекст

Требуется масштабируемый и отказоустойчивый механизм исполнения сценариев, интегрируемый с CI/CD и не зависящий от одного инстанса.

### Решение

- `POST /testruns` создаёт TestRun со статусом QUEUED и публикует задачу в `run_jobs` (БД или MQ).
- `orchestra-executor` подписывается на очередь, берёт задачу, ставит TestRun в IN_PROGRESS, выполняет шаги и записывает StepResult.
- После завершения обновляет статус TestRun и `finishedAt`.

### Альтернативы

1. Синхронное выполнение сценариев в HTTP-запросе.
2. Периодический опрос БД на наличие PENDING-прогонов.

### Последствия

Плюсы:

- Горизонтальное масштабирование воркеров.
- Восстановление после падений: задания остаются в очереди.

Минусы:

- Дополнительная инфраструктура (MQ).
- Сложность отладки распределённого Execution Engine.

### Реализация в рамках хакатона

- Допустимо хранить очередь в БД, но интерфейсы остаются теми же.
- Один воркер, демонстрирующий концепцию.

---

## ADR-0007: Side-Effect Assertions как отдельные шаги сценария

**Статус:** Accepted
**Дата:** 2025-11-14

### Контекст

Нужно проверять побочные эффекты (БД, Kafka, очереди). Возможные подходы: встраивать проверки в ACTION, делать отдельный watcher, или выделить ASSERTION-шаги.

### Решение

- Вводится `StepKind` с вариантами ACTION и ASSERTION.
- Расширяется `ChannelType` на DB, QUEUE, KAFKA.
- DB/Kafka/Queue ASSERT реализуются как отдельные `ScenarioStep` в сценарии с собственными статусами и нарушениями.

### Альтернативы

1. Прятать ASSERTION внутри ACTION.
2. Делать фоновый watcher по логам/мониторингу.

### Последствия

Плюсы:

- Сценарии читаемы: «создали заказ → проверили БД → проверили Kafka → проверили очередь».
- Единый Execution Engine для всех типов проверок.

Минусы:

- Количество шагов растёт.
- Нужно управлять нагрузкой polling-запросов.

### Реализация в рамках хакатона

- Хотя бы один DB ASSERT и один Kafka/Queue ASSERT (скелет).

---

## ADR-0008: Модель окружений и коннекторов к SUT

**Статус:** Accepted
**Дата:** 2025-11-14

### Контекст

Сценарии должны запускаться против разных стендов (dev/qa/stage). В meta шагов используются alias’ы dataSource, clusterAlias, brokerAlias.

### Решение

- Вводятся `DbConnectionProfile`, `KafkaClusterProfile`, `QueueBrokerProfile`.
- Вводится `Environment`, который маппит alias → профиль.
- В шагах сценария хранятся только alias, секреты лежат во внешнем Secret Manager.

### Альтернативы

1. Хранить полноценные DSN в каждом шаге.
2. Делать отдельные сценарии под каждое окружение.

### Последствия

Плюсы:

- Лёгкое переключение окружений.
- Централизованное управление коннекторами SUT.

Минусы:

- Дополнительные сущности и UI для настройки окружений.

### Реализация в рамках хакатона

- Минимум: alias + профиль для БД.
- UI для Environment может быть упрощённым.

---

## ADR-0009: Consistency и flakiness ASSERTION-шагов

**Статус:** Accepted
**Дата:** 2025-11-14

### Контекст

Побочные эффекты проявляются не сразу (eventual consistency). Тесты не должны быть случайно красными.

### Решение

1. ASSERTION-шаги имеют `timeoutMs` и `pollIntervalMs`.
2. При отсутствии успеха до `timeoutMs`:
   - создаётся нарушение `TIMEOUT` + специфичный тип (DB_ASSERTION_FAILED, KAFKA_MESSAGE_NOT_FOUND, QUEUE_MESSAGE_NOT_FOUND);
   - шаг помечается FAILED.
3. Post-MVP: конфигурируемые повторы и статус FLAKY, если успех достигнут со второй/третьей попытки.
4. Отчёт явно показывает таймауты и flakiness, собираются метрики.

### Альтернативы

- Не использовать polling (проверка один раз).
- Использовать слишком большие таймауты.

### Последствия

- ASSERTION шаги добавляют нагрузку на SUT (повторные SELECT/poll).
- Нужен глобальный предел времени TestRun.
- Требуется мониторинг частоты TIMEOUT/FLAKY.

---

## ADR-0010: Моделирование сложных процессов через ScenarioSuite и линейные сценарии

**Статус:** Accepted
**Дата:** 2025-11-14

### Контекст

BPMN-процессы содержат ветвления, параллельные ветки и циклы. Полноценный BPMN-движок усложнит систему, но тесты должны быть детерминированными и читаемыми.

### Решение

- Вводится `ScenarioSuite` — набор сценариев, покрывающих процесс.
- `ProcessToScenarioGenerator` строит граф управления потоком и генерирует набор линейных путей (сценариев), покрывающих ветвления, параллельные комбинации и ограниченные итерации циклов.
- Execution Engine работает с линейными `TestScenario`.

### Альтернативы

1. Выполнять BPMN «как есть» (встроенный BPMN-движок).
2. Игнорировать ветвления/параллельность.

### Последствия

Плюсы:

- Сохраняется простота Execution Engine.
- Сценарии читаемы и пригодны для ревью.

Минусы:

- Не все пути покрываются автоматически (но генератор можно расширять).

### Реализация в рамках хакатона

- Минимум один линейный сценарий на процесс.
- Заготовка для ProcessToScenarioGenerator.

---

## ADR-0011: TestDataSet и параметризация сценариев

**Статус:** Accepted
**Дата:** 2025-11-14

### Контекст

Жёстко зашитые данные делают тесты хрупкими и мешают покрывать разные классы входов.

### Решение

- Вводится `TestDataSet` как отдельная сущность.
- Шаги сценария используют плейсхолдеры `{{data.*}}` и `{{step.alias.response.*}}`.
- При запуске ExecutionContext.variables["data"] = TestDataSet.data.
- AI-сервис может генерировать/обновлять наборы данных.

### Альтернативы

1. Хранить данные прямо внутри `ScenarioStep.action.inputTemplate`.
2. Передавать данные целиком в TestRunCreateRequest без сохранения.

### Последствия

Плюсы:

- Повторное использование наборов данных.
- Разделение «что тестируем» и «на каких данных».

Минусы:

- Дополнительный уровень сущностей и UI.

---

## ADR-0012: RBAC и мультиарендность

**Статус:** Accepted
**Дата:** 2025-11-14

### Контекст

Orchestra используется разными командами/клиентами. Нельзя допускать утечек и конфликтов конфигураций.

### Решение

- Вводится `Tenant`, все ключевые сущности имеют `tenantId`.
- Модель ролей: ORG_ADMIN, TEST_DESIGNER, TEST_RUNNER, VIEWER.
- Авторизация: JWT с tenantId и roles, проверки на уровне приложения и (при необходимости) политики БД (RLS).

### Альтернативы

1. Single-tenant дизайн с логической изоляцией только на уровне UI.
2. Физически отдельная БД на каждого клиента.

### Последствия

Плюсы:

- Безопасное разделение данных между клиентами.
- Масштабируемость за счёт добавления новых tenant’ов.

Минусы:

- Усложнение схемы БД.
- Сложные миграции/операции (учитывать tenantId).

---

## ADR-0013: Версионирование артефактов и история изменений

**Статус:** Accepted
**Дата:** 2025-11-14

### Контекст

Процессы, спецификации и сценарии эволюционируют. Нужно понимать, с какой версией сценария запускался прогон и кто что менял.

### Решение

- ProcessVersion, TestScenario.version, ProtocolSpec.version.
- Изменение сценария → новая версия (copy-on-write); старая помечается DEPRECATED или остаётся PUBLISHED.
- TestRun хранит ссылку на конкретную версию сценария.
- Audit_log фиксирует события (create/update/delete, пользователь, timestamp).

### Альтернативы

1. Изменять сценарии «на месте» без версий.
2. Хранить историю только в Git.

### Последствия

Плюсы:

- Воспроизводимость прогонов.
- Возможность отката к предыдущим версиям.

Минусы:

- Рост объёма хранимых данных.
- Требуется продуманный UX версионирования.

---

## ADR-0014: Политика хранения и архивации данных

**Статус:** Accepted
**Дата:** 2025-11-14

### Контекст

Результаты тестов и отчёты быстро растут и влияют на производительность и стоимость хранения.

### Решение

- Пер-tenant политика ретеншн (по умолчанию, например, 90 дней для TestRun/TestStepResult).
- Фоновые задачи `cleanup_old_runs` удаляют/архивируют старые записи; опционально — архивирование в объектное хранилище.
- Настройки конфигурируемы для крупных клиентов.

### Альтернативы

1. Не удалять данные вообще.
2. Сразу писать отчёты только в объектное хранилище.

### Последствия

Плюсы:

- Контролируемый рост БД.
- Возможность долгосрочного хранения отчётов в архиве.

Минусы:

- Дополнительный код обслуживания.
- Нужно документировать сроки хранения.

---

## ADR-0015: MVP Scope для хакатона

**Статус:** Accepted
**Дата:** 2025-11-14

### Контекст

Хакатон ограничен по времени, требуется компромисс между полнотой архитектуры и реалистичным объёмом реализации.

### Решение (MVP Scope)

1. **Протоколы** — полный HTTP/OpenAPI плагин; Kafka/DB ASSERTION (скелеты).
2. **Диаграммы** — импорт BPMN и простых sequence-диаграмм.
3. **Сценарии** — линейные сценарии без ветвлений/циклов в Execution Engine.
4. **Execution Engine** — простая очередь задач (можно через БД), один воркер.
5. **AI** — генерация тестовых данных для HTTP (HAPPY_PATH), базовые рекомендации.
6. **UI** — импорт процессов/спек, конструктор шагов, запуск прогона, просмотр результатов и отчёта.

### Последствия

- Архитектура строится под full-scope (v4).
- MVP демонстрирует ядро «оркестра тестов бизнес-процессов».
- Дальнейшее развитие — реализация ADR-0006–0014 без перестройки архитектуры.
