---
id: ARCH-security-multitenancy
title: "Безопасность, RBAC и мультиарендность"
type: feature
layer: infrastructure
owner: '@architect'
version: v2
status: planned
created: 2024-07-29
updated: 2024-07-30
tags: [security, rbac, multitenancy, keycloak, rls]
depends_on: [ARCH-data-model]
referenced_by: []
---
## Контекст
Платформа Orchestra предназначена для использования несколькими арендаторами (тенантами). Необходимо обеспечить строгую изоляцию данных и ресурсов, а также гранулированное управление доступом внутри каждого тенанта.

## Структура

### 1. Мультиарендность: Изоляция данных

Применяется **двухуровневая стратегия изоляции** в модели "Shared Database, Shared Schema".

#### Уровень 1: Приложение (Application-Level Enforcement)
-   **`Tenant Context Propagation`:** Реализован паттерн для безопасной передачи `tenant_id`:
    1.  `Filter` извлекает `tenant_id` из JWT-токена.
    2.  `tenant_id` сохраняется в `ThreadLocal` (`TenantContextHolder`).
    3.  Все запросы к репозиториям неявно используют `tenant_id` из этого контекста для добавления `WHERE tenant_id = ...` в SQL-запросы. Это основной механизм фильтрации, использующий индексы БД.

#### Уровень 2: База данных (Database-Level Enforcement - RLS)
-   **Row-Level Security (RLS):** В PostgreSQL для всех таблиц с `tenant_id` включен RLS.
-   **Политики:** Для каждой таблицы действует политика, разрешающая доступ к строке только если ее `tenant_id` совпадает со значением в сессионной переменной (`app.current_tenant`).
-   **`SET LOCAL`:** Перед каждой транзакцией `Hibernate Interceptor` получает `tenant_id` из `TenantContextHolder` и выполняет `SET LOCAL app.current_tenant = '...'`. Это гарантирует, что даже при ошибке в коде приложения (пропущен `WHERE tenant_id`) база данных не вернет чужие данные.

### 2. Изоляция ресурсов ("Шумный сосед")

-   **`Scheduler`:** Центральный планировщик в `orchestra-api` применяет квоты (`max_parallel_runs`) для каждого тенанта, предотвращая монополизацию вычислительных ресурсов одним клиентом.
-   **Приоритетные очереди:** RabbitMQ настроен с разными очередями (например, `runs.priority.high` и `runs.priority.low`) для разделения интерактивных (UI) и фоновых (CI) задач, обеспечивая предсказуемое время отклика для пользователей.

### 3. Аутентификация и Авторизация (RBAC)

-   **Аутентификация:** Интеграция с Keycloak по протоколу OIDC. `orchestra-api` валидирует JWT-токены.
-   **Авторизация (RBAC):** Ролевая модель (`ORG_ADMIN`, `TEST_DESIGNER`, `TEST_RUNNER`, `VIEWER`) используется для гранулярного контроля доступа к API-эндпоинтам с помощью аннотаций `@PreAuthorize`.

## Поведение
1.  Пользователь аутентифицируется в Keycloak и получает JWT-токен, содержащий `userId`, `tenant_id` и `roles`.
2.  При каждом запросе к `orchestra-api` `Filter` валидирует токен и устанавливает `TenantContext`.
3.  Spring Security проверяет роли пользователя для доступа к эндпоинту.
4.  Перед выполнением запроса к БД, `Hibernate Interceptor` устанавливает сессионную переменную `app.current_tenant` для активации RLS.
5.  Репозиторий добавляет явное условие `WHERE tenant_id = ...` для эффективного использования индексов.
6.  PostgreSQL (RLS) выполняет финальную проверку, гарантируя, что запрос не выйдет за пределы данных текущего тенанта.
