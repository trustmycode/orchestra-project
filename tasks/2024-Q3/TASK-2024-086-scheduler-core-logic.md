---
id: TASK-2024-086
title: "Задача 4.8.2 (Backend): Реализация основной логики планировщика"
status: backlog
priority: high
type: task
estimate: 12h
created: 2024-07-30
parents: [TASK-2024-084]
dependencies: [TASK-2024-085]
arch_refs: [ADR-0020]
---
## Описание
Создать основной компонент `SchedulerService`, который будет периодически выполняться и принимать решения о том, какие `TestRun`'ы отправить на выполнение, реализуя fairness-алгоритм из `ADR-0020`.

## Ключевые шаги
1. Создать `SchedulerService` в `orchestra-api`.
2. Реализовать метод, аннотированный `@Scheduled`, который будет запускаться, например, каждые 5 секунд.
3. **Логика выборки:**
   a. Получить список всех тенантов, у которых есть `PENDING` задачи.
   b. Для каждого тенанта:
      i. Получить его лимит `max_parallel_runs` из `tenant_settings`.
      ii. Посчитать количество его активных задач (`QUEUED` + `IN_PROGRESS`).
      iii. Вычислить доступный "слот" (`slot = limit - active_runs`).
   c. Если `slot > 0`, выбрать `slot` задач из `PENDING` для этого тенанта (сначала с более высоким `priority`).
4. **Действие:** Для всех выбранных на запуск `TestRun`'ов:
   a. Атомарно обновить их статус на `QUEUED`.
   b. Отправить сообщения с их `testRunId` в очередь RabbitMQ.

## Критерии приемки
- Планировщик корректно выбирает `PENDING` задачи, не превышая лимиты для каждого тенанта.
- Выбранные задачи переводятся в статус `QUEUED`, и соответствующие сообщения отправляются в RabbitMQ.
- Если лимит исчерпан, `PENDING` задачи остаются в ожидании следующего цикла планировщика.
- Логика fairness документирована и покрывает сценарии, перечисленные в ADR.
